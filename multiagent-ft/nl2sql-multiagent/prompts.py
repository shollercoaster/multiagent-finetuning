import os, json
from string import Template
from typing import List

# Load your API key from environment
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# 1. Schema Agent prompt
def schema_agent_prompt(question: str, schema_list: str) -> str:
    return Template(
        """
You are a Schema Agent in an NL2SQL framework. Given a natural language question and table schemas (with columns, PKs, and FKs), identify the relevant tables and columns needed, including intermediate tables for joins.

Question: $question
Schemas:
$schema_list

Return a list of lines in the format:
Table: primary_key_col, foreign_key_col, col1, col2, ...

ALWAYS list Foreign Key and Primary Key information.
ONLY list relevant tables and columns in given format and no other extra characters.
"""
    ).substitute(question=question, schema_list=schema_list)

def alt_schema_linking_agent_prompt(question: str, table_schema: str, schema_agent_output="") -> str:
    return Template(
        """
You are a Schema Linking Agent in an NL2SQL framework. Find the schema_links for generating SQL query for the question based on the database schema and Foreign keys.\n"

Question: $question
Table Schema:
$table_schema

Return the schema links in given format:
Table1: Col1, Col2..
Foreign Keys = (Table1.ColXYZ, Tabl2.ColXYZ).. 
ONLY list relevant tables and columns and Foreign Keys in given format and no other extra characters.
"""
    ).substitute(
        question=question,
        table_schema=table_schema)

# 1.a Schema Linking Agent Prompt
def schema_linking_agent_prompt(question: str, table_schema: str, schema_agent_output: str) -> str:
    return Template(
        """
You are a Schema Linking Agent in an NL2SQL framework. Your job is to verify the schema agent's output and ensure all necessary schema relationships are included.

Given:
- A natural language question
- Database schemas with columns, primary keys (PK), and foreign keys (FK)
- The output of a Schema Agent listing relevant tables and columns

Check for:
- Missing or incorrect FK-PK relationships and add them
- Incomplete column selections (especially join keys)
- Table alias mismatches
- Linkage errors that would lead to incorrect joins or groupBy clauses

If issues exist, correct them by editing ONLY the schema agent's output.

Inputs:
Question: $question

Schemas:
$schema_list

Schema Agent Output:
$schema_agent_output

Correct and return the fixed output in the SAME format:
Table: primary_key_col, foreign_key_col, col1, col2, ...
"""
    ).substitute(
        question=question,
        schema_list=table_schema,
        schema_agent_output=schema_agent_output,
    )

# 2. Subproblem Agent prompt
def subproblem_agent_prompt(question: str, schema_info: str) -> str:
    return Template(
        """
You are a Subproblem Agent in an NL2SQL framework. Your task is to decompose a natural language question into SQL subproblems.

You will be provided:
- A natural language question
- A textual schema summary that lists relevant tables and columns (generated by a Schema Agent)

Use this information to infer which SQL clauses are likely needed (e.g., WHERE, GROUP BY, ORDER BY, JOIN, HAVING, LIMIT, INTERSECT).

Question:
$question

Schema:
$schema

Output a JSON object containing a list of subproblems:
{
  "subproblems": [
    { "clause": "SELECT", "expression": "..." },
    { "clause": "JOIN", "expression": "..." },
    ...
  ]
}

Only output valid JSON — no markdown, no extra commentary.

"""
    ).substitute(question=question.strip(), schema=schema_info.strip())

def bird_subproblem_agent_prompt(question: str, schema_info: str, evidence:str) -> str:
    return Template(
        """
You are a Subproblem Agent. Your task is to decompose a natural language question into SQL subproblems.

You will be provided:
- A natural language question
- A textual schema summary that lists relevant tables and columns (generated by a Schema Agent)
- Evidence: helpful information about the domain, formulas, or data relevant to query generation

Use this information to infer which SQL clauses are likely needed other than SELECT (e.g., WHERE, GROUP BY, ORDER BY, JOIN, HAVING, LIMIT, INTE>
Output a JSON object containing a list of subproblems:
{
  "subproblems": [
    { "clause": "SELECT", "expression": "..." },
    { "clause": "WHERE", "expression": "..." },
    ...
  ]
}

Only output valid JSON — no markdown, no extra commentary.

Question:
$question

Schema:
$schema

Evidence:
$evidence
"""
    ).substitute(question=question.strip(), schema=schema_info.strip(), evidence=evidence.strip())

# 3. Query Plan Agent prompt
def query_plan_agent_prompt(question: str, schema_info: str, subproblem_json, subprob_plan="", critic_issues: list = None) -> str:
    base_prompt = Template(
        """
You are a Query Plan Agent in an NL2SQL Framework. Using the question, schema info, and subproblems, generate a step-by-step SQL query plan.

Question: $question
Schema Info:
$schema_info
Subproblems:
$subproblem_json

$critic_feedback

$subprob_plan

Return plan steps with specific table, column names like:
1. FROM tableA
2. JOIN tableB ON tableA.colX = tableB.colY
3. JOIN tableC ON tableB.colZ = tableC.colW

Return only the plan (no SQL or extra text).
"""
    )
    if critic_issues:
        feedback = "\nPREVIOUS ERRORS TO AVOID:\n" # "\nIMPORTANT: Avoid the following errors detected in the earlier SQL attempt:\n"
        feedback += "\n".join([f"- {issue}" for issue in critic_issues])
        feedback += "\n Generate a query plan that FIXES all listed errors.\n"
    else:
        feedback = ""

    return base_prompt.substitute(question=question, schema_info=schema_info, subproblem_json=subproblem_json, critic_feedback=feedback, subprob_plan=subprob_plan)

def bird_query_plan_agent_prompt(question: str, schema_info: str, subproblem_json: str, evidence: str):
    return Template(
        """
You are a Query Plan Agent. Using the question, schema info, and subproblems, generate a step-by-step SQL query plan. Use the evidence to understand helpful domain information, or additional data needed to generate sql query.


Question: $question
Schema Info:
$schema_info
Subproblems:
$subproblem_json
Evidence:
$evidence

Provide a concise and to-the-point plan, each step describing how to build parts of the SQL.
"""
    ).substitute(question=question, schema_info=schema_info, subproblem_json=subproblem_json, evidence=evidence.strip())

# 4. SQL Generating Agent prompt
def bird_sql_agent_prompt(plan: str, evidence: str) -> str:
    return Template(
        """
You are an SQL Generating Agent. Given the plan, write ONLY the final SQL query with no extra text or formatting. Use the evidence to understand helpful domain information, or additional data needed to generate sql query.

Plan:
$plan
Evidence:
$evidence

Return exactly one valid SQL statement.
"""
    ).substitute(plan=plan, evidence=evidence)

# 4. SQL Generating Agent prompt
def sql_agent_prompt(plan: str, schema=None, subprob_sql="", critic_issues : list = None) -> str:
    base_prompt = Template(
        """
You are an SQL Generating Agent in an NL2SQL framework. Given the plan, write ONLY the final SQL query with no extra text or formatting.

Plan:
$plan

$schema

$subprob_sql

$critic_feedback

Write ONLY the final valid SQL query. Do NOT include commentary.
"""
    )
    if critic_issues:
        # feedback = "\nIMPORTANT: Avoid the following errors found in the earlier SQL attempt:\n"
        feedback = "\nENSURE THAT YOU ADDRESS THESE ERRORS:\n" + "\n".join(f"- {e}" for e in critic_issues)
        # feedback += "\n".join([f"- {issue}" for issue in critic_issues])
    else:
        feedback = ""
    if schema:
        schema_info = "\n Relevant Table Schema: \n" + schema
    else:
        schema_info = ""
    return base_prompt.substitute(plan=plan, schema=schema_info, critic_feedback=feedback, subprob_sql=subprob_sql)


# 5. Critic Agent prompt
def nl2sqlbugs_critic_agent_prompt(sql: str, bug_list: str) -> str:
    return Template(
        """
You are a Critic Agent. Validate the SQL query against known NL2SQL bug patterns.

Original SQL: $sql
Known bugs database: $bug_list

If you find errors, output JSON:{"error": "<description>"}
Otherwise output:{"valid": true}
"""
    ).substitute(sql=sql, bug_list=bug_list)

def critic_agent_prompt(question: str, sql: str) -> str:
    return Template(
    """
You are a Critic Agent. Your job is to inspect a SQL query and determine whether it is logically and structurally valid.

Check for:
- Logical fallacies (e.g. comparing two incompatible types)
- Incorrect/missing joins
- Missing clauses required to answer the question
- Aggregations used incorrectly
- Hardcoded values that should come from a column
- Unused subqueries or tables

Question:
{question}

SQL Query:
{sql}

Return **only** one of the following:

1. If the SQL is valid:

{
   "valid": true
}

2. If the SQL has issues:

{
  "valid": false,
  "error_types": [
    {"error_type": "explanation"},
    ...
  ]
}

DO NOT add any explanation, markdown, or text outside this JSON. Only valid JSON.
Only return errors if you find them. Don't complicate things.
"""
    ).substitute(question=question.strip(), sql=sql.strip())

def taxonomy_critic_agent_prompt(question: str, sql: str, taxonomy: dict, schema) -> str:
    taxonomy_str = json.dumps(taxonomy, indent=2)
    return f"""
You are a Critic Agent. Given an NL question and generated SQL, identify structural or semantic errors based on the following taxonomy (9 categories, 36 subtypes):

{taxonomy}

Input:
Question: {question}
SQL: {sql}
Schema: {schema}

Return **only** JSON following this schema:

If no errors:
{{
  "valid": true
}}

If there are errors:
{{
  "valid": false,
  "error_types": [ "category.subtype", ... ]
}}

Check also for, and mention the name of column or table that's missing or extra:
- join_missing_table
- join_wrong_column
- table_forbidden

Example: ["join.missing_table - (table_name)", "join.extra_col - (col_name)", "aggregation.agg_no_groupby"]

Return only JSON, no other commentary."""

def plan_sanity_agent_prompt(question: str,
                             schema_output: str,
                             plan: str,
                             clause_prompts="",
                             subproblem_output="") -> str:
    base = Template(
        """
You are a **Plan Sanity Checker Agent** in an NL2SQL framework. Your task is to read the question, review the SQL plan and ensure it **structurally matches** the intended intent from the schema and subproblem breakdown.

Inputs:
Question:
$question

Selected Schema Lines:
$schema_output
$subproblems

Original Plan to Validate:
$plan

Check that:
- All necessary tables appear in `FROM` and `JOIN` steps with correct join keys.
- GROUP BY, HAVING, ORDER BY, LIMIT clauses appear in the proper order and ONLY when they're necessary.
- Filter operations (WHERE/HAVING) match the subproblem intent.
- There are no extra tables or columns beyond intent.

$clause_prompts
Remove the issues from the original plan, and summarize the revised plan + error highlights into a few sentences. Pass that summary instead of the raw history.
Example: “Plan summary: joined tables A–B–C via columns X.Y and Y.Z; GROUP BY on col Z. Found missing join to table D on A.K = D.K.”
""")
    """
Return either:
1. `VALID PLAN` if Original plan is correct
2. If you spot issues, return a revised plan, step-by-step, with minimal edits, numbered lines, and nothing else.
    """
    if subproblem_output != "":
        subproblems = "\nSubproblems Identified: \n" + subproblem_output
    else:
        subproblems = ""
    return base.substitute(
        question=question,
        schema_output=schema_output,
        subproblems=subproblems, clause_prompts=clause_prompts,
        plan=plan,
    )


def repair_agent_prompt(issue: str, sql: str, question: str, schema):
    return f"""
You are a Repair Agent in an NL2SQL framework. There’s a {issue} error. Given the question, relevant table schema, the generated SQL, fix the error.

Question:
{question}
Schema:
{schema}
Generated SQL:
{sql}

Fix only the {issue}, keeping other logic intact.
"""

def repair_combined_agent_prompt(repaired_sqls, question):
    lines = []
    for issue, sql in repaired_sqls.items():
        lines.append(f"Issue: {issue}\nRepaired SQL:\n{sql}")
    body = "\n\n".join(lines)
    return f"""
You are a Repair Combining Agent in an NL2SQL framework. Different repair agents each fixed a specific issue in the SQL query. Combine their outputs into one coherent final SQL. 
Make sure to KEEP ALL FIXES while avoiding conflicts. 

Original Question:
{question}

Available fixed versions:
{body}

Produce a single SQL query that integrates all corrections. Return only the final SQL.
"""
