{
  "subproblem": "orderby",
  "total_samples": 12,
  "exec_match_false_count": 6,
  "exec_match_false_pct": 50.0,
  "false_samples": [
    {
      "question": "Show the stadium name and capacity with most number of concerts in year 2014 or after.",
      "db_id": "concert_singer",
      "agents": {
        "schema": {
          "prompt": "\nYou are a Schema Agent. Given a natural language question and table schemas, identify the relevant tables and columns.\n\nQuestion: Show the stadium name and capacity with most number of concerts in year 2014 or after.\nSchemas:\nstadium:\n  Stadium_ID\n  Location\n  Name\n  Capacity\n  Highest\n  Lowest\n  Average\nsinger:\n  Singer_ID\n  Name\n  Country\n  Song_Name\n  Song_release_year\n  Age\n  Is_male\nconcert:\n  concert_ID\n  concert_Name\n  Theme\n  Stadium_ID\n  Year\nsinger_in_concert:\n  concert_ID\n  Singer_ID\n\nReturn a list of lines in the format:\nTable: col1, col2, ...\nOnly list relevant tables and columns needed to answer the question.\n",
          "output": "```\nTable: stadium, Name, Capacity\nTable: concert, Stadium_ID, Year\n```"
        },
        "subproblem": {
          "prompt": "\nYou are a Subproblem Agent. Your task is to decompose a natural language question into SQL subproblems.\n\nYou will be provided:\n- A natural language question\n- A textual schema summary that lists relevant tables and columns (generated by a Schema Agent)\n\nUse this information to infer which SQL clauses are likely needed other than SELECT (e.g., WHERE, GROUP BY, ORDER BY, JOIN, HAVING, LIMIT, INTERSECT).\n\nOutput a JSON object containing a list of subproblems:\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"...\" },\n    { \"clause\": \"WHERE\", \"expression\": \"...\" },\n    ...\n  ]\n}\n\nOnly output valid JSON \u2014 no markdown, no extra commentary.\n\nQuestion:\nShow the stadium name and capacity with most number of concerts in year 2014 or after.\n\nSchema:\n```\nTable: stadium, Name, Capacity\nTable: concert, Stadium_ID, Year\n```\n",
          "output": "```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"stadium.Name, stadium.Capacity\" },\n    { \"clause\": \"JOIN\", \"expression\": \"stadium ON stadium.ID = concert.Stadium_ID\" },\n    { \"clause\": \"WHERE\", \"expression\": \"concert.Year >= 2014\" },\n    { \"clause\": \"GROUP BY\", \"expression\": \"stadium.Name, stadium.Capacity\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"COUNT(concert.Stadium_ID) DESC\" },\n    { \"clause\": \"LIMIT\", \"expression\": \"1\" }\n  ]\n}\n```"
        },
        "plan": {
          "prompt": "\nYou are a Query Plan Agent. Using the question, schema info, and subproblems, generate a step-by-step SQL query plan.\n\nQuestion: Show the stadium name and capacity with most number of concerts in year 2014 or after.\nSchema Info:\n```\nTable: stadium, Name, Capacity\nTable: concert, Stadium_ID, Year\n```\nSubproblems:\n```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"stadium.Name, stadium.Capacity\" },\n    { \"clause\": \"JOIN\", \"expression\": \"stadium ON stadium.ID = concert.Stadium_ID\" },\n    { \"clause\": \"WHERE\", \"expression\": \"concert.Year >= 2014\" },\n    { \"clause\": \"GROUP BY\", \"expression\": \"stadium.Name, stadium.Capacity\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"COUNT(concert.Stadium_ID) DESC\" },\n    { \"clause\": \"LIMIT\", \"expression\": \"1\" }\n  ]\n}\n```\n\nProvide a concise and to-the-point plan, each step describing how to build parts of the SQL.\n",
          "output": "1. **SELECT Clause**: Start by selecting the columns you need from the `stadium` table, which are `stadium.Name` and `stadium.Capacity`.\n\n2. **JOIN Clause**: Perform an INNER JOIN between the `stadium` and `concert` tables. Use the condition `stadium.ID = concert.Stadium_ID` to link concerts to their respective stadiums.\n\n3. **WHERE Clause**: Filter the results to include only those concerts that occurred in the year 2014 or later. This is done by adding the condition `concert.Year >= 2014`.\n\n4. **GROUP BY Clause**: Group the results by `stadium.Name` and `stadium.Capacity` to aggregate the data for each stadium.\n\n5. **ORDER BY Clause**: Order the grouped results by the count of concerts in descending order. This will help in identifying the stadium with the most concerts.\n\n6. **LIMIT Clause**: Limit the results to only one record to get the stadium with the highest number of concerts.\n\nBy following these steps, you will construct a query that retrieves the stadium name and capacity with the most concerts from 2014 onwards."
        },
        "sql": {
          "prompt": "\nYou are an SQL Generating Agent. Given the plan, write ONLY the final SQL query with no extra text or formatting.\n\nPlan:\n1. **SELECT Clause**: Start by selecting the columns you need from the `stadium` table, which are `stadium.Name` and `stadium.Capacity`.\n\n2. **JOIN Clause**: Perform an INNER JOIN between the `stadium` and `concert` tables. Use the condition `stadium.ID = concert.Stadium_ID` to link concerts to their respective stadiums.\n\n3. **WHERE Clause**: Filter the results to include only those concerts that occurred in the year 2014 or later. This is done by adding the condition `concert.Year >= 2014`.\n\n4. **GROUP BY Clause**: Group the results by `stadium.Name` and `stadium.Capacity` to aggregate the data for each stadium.\n\n5. **ORDER BY Clause**: Order the grouped results by the count of concerts in descending order. This will help in identifying the stadium with the most concerts.\n\n6. **LIMIT Clause**: Limit the results to only one record to get the stadium with the highest number of concerts.\n\nBy following these steps, you will construct a query that retrieves the stadium name and capacity with the most concerts from 2014 onwards.\n\nReturn exactly one valid SQL statement.\n",
          "output": "select stadium.name, stadium.capacity from stadium inner join concert on stadium.id = concert.stadium_id where concert.year >= 2014 group by stadium.name, stadium.capacity order by count(concert.id) desc limit 1"
        }
      },
      "gold_sql": "select t2.name, t2.capacity from concert as t1 join stadium as t2 on t1.stadium_id = t2.stadium_id where t1.year >= 2014 group by t2.stadium_id order by count(*) desc limit 1",
      "exact_match": false,
      "valid_sql": false,
      "exec_match": false
    },
    {
      "question": "What is the name and capacity of the stadium with the most concerts after 2013 ?",
      "db_id": "concert_singer",
      "agents": {
        "schema": {
          "prompt": "\nYou are a Schema Agent. Given a natural language question and table schemas, identify the relevant tables and columns.\n\nQuestion: What is the name and capacity of the stadium with the most concerts after 2013 ?\nSchemas:\nstadium:\n  Stadium_ID\n  Location\n  Name\n  Capacity\n  Highest\n  Lowest\n  Average\nsinger:\n  Singer_ID\n  Name\n  Country\n  Song_Name\n  Song_release_year\n  Age\n  Is_male\nconcert:\n  concert_ID\n  concert_Name\n  Theme\n  Stadium_ID\n  Year\nsinger_in_concert:\n  concert_ID\n  Singer_ID\n\nReturn a list of lines in the format:\nTable: col1, col2, ...\nOnly list relevant tables and columns needed to answer the question.\n",
          "output": "```\nTable: stadium, Name, Capacity\nTable: concert, Stadium_ID, Year\n```"
        },
        "subproblem": {
          "prompt": "\nYou are a Subproblem Agent. Your task is to decompose a natural language question into SQL subproblems.\n\nYou will be provided:\n- A natural language question\n- A textual schema summary that lists relevant tables and columns (generated by a Schema Agent)\n\nUse this information to infer which SQL clauses are likely needed other than SELECT (e.g., WHERE, GROUP BY, ORDER BY, JOIN, HAVING, LIMIT, INTERSECT).\n\nOutput a JSON object containing a list of subproblems:\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"...\" },\n    { \"clause\": \"WHERE\", \"expression\": \"...\" },\n    ...\n  ]\n}\n\nOnly output valid JSON \u2014 no markdown, no extra commentary.\n\nQuestion:\nWhat is the name and capacity of the stadium with the most concerts after 2013 ?\n\nSchema:\n```\nTable: stadium, Name, Capacity\nTable: concert, Stadium_ID, Year\n```\n",
          "output": "```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"stadium.Name, stadium.Capacity\" },\n    { \"clause\": \"JOIN\", \"expression\": \"stadium ON stadium.ID = concert.Stadium_ID\" },\n    { \"clause\": \"WHERE\", \"expression\": \"concert.Year > 2013\" },\n    { \"clause\": \"GROUP BY\", \"expression\": \"stadium.ID\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"COUNT(concert.Stadium_ID) DESC\" },\n    { \"clause\": \"LIMIT\", \"expression\": \"1\" }\n  ]\n}\n```"
        },
        "plan": {
          "prompt": "\nYou are a Query Plan Agent. Using the question, schema info, and subproblems, generate a step-by-step SQL query plan.\n\nQuestion: What is the name and capacity of the stadium with the most concerts after 2013 ?\nSchema Info:\n```\nTable: stadium, Name, Capacity\nTable: concert, Stadium_ID, Year\n```\nSubproblems:\n```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"stadium.Name, stadium.Capacity\" },\n    { \"clause\": \"JOIN\", \"expression\": \"stadium ON stadium.ID = concert.Stadium_ID\" },\n    { \"clause\": \"WHERE\", \"expression\": \"concert.Year > 2013\" },\n    { \"clause\": \"GROUP BY\", \"expression\": \"stadium.ID\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"COUNT(concert.Stadium_ID) DESC\" },\n    { \"clause\": \"LIMIT\", \"expression\": \"1\" }\n  ]\n}\n```\n\nProvide a concise and to-the-point plan, each step describing how to build parts of the SQL.\n",
          "output": "1. **SELECT Clause**: Start by selecting the columns you need from the `stadium` table. Specifically, you want the `Name` and `Capacity` of the stadium. This will form the basis of the information you want to retrieve.\n\n   ```sql\n   SELECT stadium.Name, stadium.Capacity\n   ```\n\n2. **JOIN Clause**: To associate concerts with their respective stadiums, perform an inner join between the `stadium` and `concert` tables. Use the `Stadium_ID` from the `concert` table and the `ID` from the `stadium` table to establish this relationship.\n\n   ```sql\n   FROM concert\n   JOIN stadium ON stadium.ID = concert.Stadium_ID\n   ```\n\n3. **WHERE Clause**: Filter the concerts to only include those that occurred after the year 2013. This ensures that only relevant concerts are considered in the subsequent steps.\n\n   ```sql\n   WHERE concert.Year > 2013\n   ```\n\n4. **GROUP BY Clause**: Group the results by the `stadium.ID` to aggregate concert data for each stadium. This allows you to count the number of concerts per stadium.\n\n   ```sql\n   GROUP BY stadium.ID\n   ```\n\n5. **ORDER BY Clause**: Order the grouped results by the count of concerts in descending order. This will help in identifying the stadium with the most concerts.\n\n   ```sql\n   ORDER BY COUNT(concert.Stadium_ID) DESC\n   ```\n\n6. **LIMIT Clause**: Finally, limit the results to just one record to get the stadium with the highest number of concerts after 2013.\n\n   ```sql\n   LIMIT 1\n   ```\n\nCombine all these steps to form the complete SQL query:\n\n```sql\nSELECT stadium.Name, stadium.Capacity\nFROM concert\nJOIN stadium ON stadium.ID = concert.Stadium_ID\nWHERE concert.Year > 2013\nGROUP BY stadium.ID\nORDER BY COUNT(concert.Stadium_ID) DESC\nLIMIT 1\n```"
        },
        "sql": {
          "prompt": "\nYou are an SQL Generating Agent. Given the plan, write ONLY the final SQL query with no extra text or formatting.\n\nPlan:\n1. **SELECT Clause**: Start by selecting the columns you need from the `stadium` table. Specifically, you want the `Name` and `Capacity` of the stadium. This will form the basis of the information you want to retrieve.\n\n   ```sql\n   SELECT stadium.Name, stadium.Capacity\n   ```\n\n2. **JOIN Clause**: To associate concerts with their respective stadiums, perform an inner join between the `stadium` and `concert` tables. Use the `Stadium_ID` from the `concert` table and the `ID` from the `stadium` table to establish this relationship.\n\n   ```sql\n   FROM concert\n   JOIN stadium ON stadium.ID = concert.Stadium_ID\n   ```\n\n3. **WHERE Clause**: Filter the concerts to only include those that occurred after the year 2013. This ensures that only relevant concerts are considered in the subsequent steps.\n\n   ```sql\n   WHERE concert.Year > 2013\n   ```\n\n4. **GROUP BY Clause**: Group the results by the `stadium.ID` to aggregate concert data for each stadium. This allows you to count the number of concerts per stadium.\n\n   ```sql\n   GROUP BY stadium.ID\n   ```\n\n5. **ORDER BY Clause**: Order the grouped results by the count of concerts in descending order. This will help in identifying the stadium with the most concerts.\n\n   ```sql\n   ORDER BY COUNT(concert.Stadium_ID) DESC\n   ```\n\n6. **LIMIT Clause**: Finally, limit the results to just one record to get the stadium with the highest number of concerts after 2013.\n\n   ```sql\n   LIMIT 1\n   ```\n\nCombine all these steps to form the complete SQL query:\n\n```sql\nSELECT stadium.Name, stadium.Capacity\nFROM concert\nJOIN stadium ON stadium.ID = concert.Stadium_ID\nWHERE concert.Year > 2013\nGROUP BY stadium.ID\nORDER BY COUNT(concert.Stadium_ID) DESC\nLIMIT 1\n```\n\nReturn exactly one valid SQL statement.\n",
          "output": "select stadium.name, stadium.capacity from concert join stadium on stadium.id = concert.stadium_id where concert.year > 2013 group by stadium.id order by count(concert.stadium_id) desc limit 1"
        }
      },
      "gold_sql": "select t2.name, t2.capacity from concert as t1 join stadium as t2 on t1.stadium_id = t2.stadium_id where t1.year > 2013 group by t2.stadium_id order by count(*) desc limit 1",
      "exact_match": false,
      "valid_sql": false,
      "exec_match": false
    },
    {
      "question": "Which year has most number of concerts?",
      "db_id": "concert_singer",
      "agents": {
        "schema": {
          "prompt": "\nYou are a Schema Agent. Given a natural language question and table schemas, identify the relevant tables and columns.\n\nQuestion: Which year has most number of concerts?\nSchemas:\nstadium:\n  Stadium_ID\n  Location\n  Name\n  Capacity\n  Highest\n  Lowest\n  Average\nsinger:\n  Singer_ID\n  Name\n  Country\n  Song_Name\n  Song_release_year\n  Age\n  Is_male\nconcert:\n  concert_ID\n  concert_Name\n  Theme\n  Stadium_ID\n  Year\nsinger_in_concert:\n  concert_ID\n  Singer_ID\n\nReturn a list of lines in the format:\nTable: col1, col2, ...\nOnly list relevant tables and columns needed to answer the question.\n",
          "output": "```\nTable: concert, Year\n```"
        },
        "subproblem": {
          "prompt": "\nYou are a Subproblem Agent. Your task is to decompose a natural language question into SQL subproblems.\n\nYou will be provided:\n- A natural language question\n- A textual schema summary that lists relevant tables and columns (generated by a Schema Agent)\n\nUse this information to infer which SQL clauses are likely needed other than SELECT (e.g., WHERE, GROUP BY, ORDER BY, JOIN, HAVING, LIMIT, INTERSECT).\n\nOutput a JSON object containing a list of subproblems:\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"...\" },\n    { \"clause\": \"WHERE\", \"expression\": \"...\" },\n    ...\n  ]\n}\n\nOnly output valid JSON \u2014 no markdown, no extra commentary.\n\nQuestion:\nWhich year has most number of concerts?\n\nSchema:\n```\nTable: concert, Year\n```\n",
          "output": "```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"Year, COUNT(*) AS concert_count\" },\n    { \"clause\": \"GROUP BY\", \"expression\": \"Year\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"concert_count DESC\" },\n    { \"clause\": \"LIMIT\", \"expression\": \"1\" }\n  ]\n}\n```"
        },
        "plan": {
          "prompt": "\nYou are a Query Plan Agent. Using the question, schema info, and subproblems, generate a step-by-step SQL query plan.\n\nQuestion: Which year has most number of concerts?\nSchema Info:\n```\nTable: concert, Year\n```\nSubproblems:\n```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"Year, COUNT(*) AS concert_count\" },\n    { \"clause\": \"GROUP BY\", \"expression\": \"Year\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"concert_count DESC\" },\n    { \"clause\": \"LIMIT\", \"expression\": \"1\" }\n  ]\n}\n```\n\nProvide a concise and to-the-point plan, each step describing how to build parts of the SQL.\n",
          "output": "1. **Select Clause**: Start by selecting the `Year` column and use the `COUNT(*)` function to count the number of concerts for each year. Alias this count as `concert_count`. This will help in identifying how many concerts occurred in each year.\n   ```sql\n   SELECT Year, COUNT(*) AS concert_count\n   ```\n\n2. **Group By Clause**: Group the results by the `Year` column. This ensures that the count of concerts is calculated for each distinct year.\n   ```sql\n   GROUP BY Year\n   ```\n\n3. **Order By Clause**: Order the grouped results by `concert_count` in descending order. This will arrange the years such that the year with the most concerts appears first.\n   ```sql\n   ORDER BY concert_count DESC\n   ```\n\n4. **Limit Clause**: Use the `LIMIT` clause to restrict the result set to only the top entry, which corresponds to the year with the highest number of concerts.\n   ```sql\n   LIMIT 1\n   ```\n\nCombine these steps to form the complete SQL query:\n```sql\nSELECT Year, COUNT(*) AS concert_count\nFROM concert\nGROUP BY Year\nORDER BY concert_count DESC\nLIMIT 1\n```"
        },
        "sql": {
          "prompt": "\nYou are an SQL Generating Agent. Given the plan, write ONLY the final SQL query with no extra text or formatting.\n\nPlan:\n1. **Select Clause**: Start by selecting the `Year` column and use the `COUNT(*)` function to count the number of concerts for each year. Alias this count as `concert_count`. This will help in identifying how many concerts occurred in each year.\n   ```sql\n   SELECT Year, COUNT(*) AS concert_count\n   ```\n\n2. **Group By Clause**: Group the results by the `Year` column. This ensures that the count of concerts is calculated for each distinct year.\n   ```sql\n   GROUP BY Year\n   ```\n\n3. **Order By Clause**: Order the grouped results by `concert_count` in descending order. This will arrange the years such that the year with the most concerts appears first.\n   ```sql\n   ORDER BY concert_count DESC\n   ```\n\n4. **Limit Clause**: Use the `LIMIT` clause to restrict the result set to only the top entry, which corresponds to the year with the highest number of concerts.\n   ```sql\n   LIMIT 1\n   ```\n\nCombine these steps to form the complete SQL query:\n```sql\nSELECT Year, COUNT(*) AS concert_count\nFROM concert\nGROUP BY Year\nORDER BY concert_count DESC\nLIMIT 1\n```\n\nReturn exactly one valid SQL statement.\n",
          "output": "select year, count(*) as concert_count from concert group by year order by concert_count desc limit 1"
        }
      },
      "gold_sql": "select year from concert group by year order by count(*) desc limit 1",
      "exact_match": false,
      "valid_sql": true,
      "exec_match": false
    },
    {
      "question": "What is the year that had the most concerts?",
      "db_id": "concert_singer",
      "agents": {
        "schema": {
          "prompt": "\nYou are a Schema Agent. Given a natural language question and table schemas, identify the relevant tables and columns.\n\nQuestion: What is the year that had the most concerts?\nSchemas:\nstadium:\n  Stadium_ID\n  Location\n  Name\n  Capacity\n  Highest\n  Lowest\n  Average\nsinger:\n  Singer_ID\n  Name\n  Country\n  Song_Name\n  Song_release_year\n  Age\n  Is_male\nconcert:\n  concert_ID\n  concert_Name\n  Theme\n  Stadium_ID\n  Year\nsinger_in_concert:\n  concert_ID\n  Singer_ID\n\nReturn a list of lines in the format:\nTable: col1, col2, ...\nOnly list relevant tables and columns needed to answer the question.\n",
          "output": "```\nTable: concert, Year\n```"
        },
        "subproblem": {
          "prompt": "\nYou are a Subproblem Agent. Your task is to decompose a natural language question into SQL subproblems.\n\nYou will be provided:\n- A natural language question\n- A textual schema summary that lists relevant tables and columns (generated by a Schema Agent)\n\nUse this information to infer which SQL clauses are likely needed other than SELECT (e.g., WHERE, GROUP BY, ORDER BY, JOIN, HAVING, LIMIT, INTERSECT).\n\nOutput a JSON object containing a list of subproblems:\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"...\" },\n    { \"clause\": \"WHERE\", \"expression\": \"...\" },\n    ...\n  ]\n}\n\nOnly output valid JSON \u2014 no markdown, no extra commentary.\n\nQuestion:\nWhat is the year that had the most concerts?\n\nSchema:\n```\nTable: concert, Year\n```\n",
          "output": "```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"Year, COUNT(*) AS concert_count\" },\n    { \"clause\": \"GROUP BY\", \"expression\": \"Year\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"concert_count DESC\" },\n    { \"clause\": \"LIMIT\", \"expression\": \"1\" }\n  ]\n}\n```"
        },
        "plan": {
          "prompt": "\nYou are a Query Plan Agent. Using the question, schema info, and subproblems, generate a step-by-step SQL query plan.\n\nQuestion: What is the year that had the most concerts?\nSchema Info:\n```\nTable: concert, Year\n```\nSubproblems:\n```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"Year, COUNT(*) AS concert_count\" },\n    { \"clause\": \"GROUP BY\", \"expression\": \"Year\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"concert_count DESC\" },\n    { \"clause\": \"LIMIT\", \"expression\": \"1\" }\n  ]\n}\n```\n\nProvide a concise and to-the-point plan, each step describing how to build parts of the SQL.\n",
          "output": "1. **Select Clause**: Start by selecting the `Year` column from the `concert` table. Additionally, use the `COUNT(*)` function to count the number of concerts for each year, and alias this count as `concert_count`.\n\n   ```sql\n   SELECT Year, COUNT(*) AS concert_count\n   ```\n\n2. **Group By Clause**: Group the results by the `Year` column to aggregate the concert counts for each year.\n\n   ```sql\n   GROUP BY Year\n   ```\n\n3. **Order By Clause**: Order the grouped results by `concert_count` in descending order to identify the year with the most concerts.\n\n   ```sql\n   ORDER BY concert_count DESC\n   ```\n\n4. **Limit Clause**: Limit the result set to only one row to get the year with the highest number of concerts.\n\n   ```sql\n   LIMIT 1\n   ```\n\nCombine all steps into the final SQL query:\n\n```sql\nSELECT Year, COUNT(*) AS concert_count\nFROM concert\nGROUP BY Year\nORDER BY concert_count DESC\nLIMIT 1;\n```"
        },
        "sql": {
          "prompt": "\nYou are an SQL Generating Agent. Given the plan, write ONLY the final SQL query with no extra text or formatting.\n\nPlan:\n1. **Select Clause**: Start by selecting the `Year` column from the `concert` table. Additionally, use the `COUNT(*)` function to count the number of concerts for each year, and alias this count as `concert_count`.\n\n   ```sql\n   SELECT Year, COUNT(*) AS concert_count\n   ```\n\n2. **Group By Clause**: Group the results by the `Year` column to aggregate the concert counts for each year.\n\n   ```sql\n   GROUP BY Year\n   ```\n\n3. **Order By Clause**: Order the grouped results by `concert_count` in descending order to identify the year with the most concerts.\n\n   ```sql\n   ORDER BY concert_count DESC\n   ```\n\n4. **Limit Clause**: Limit the result set to only one row to get the year with the highest number of concerts.\n\n   ```sql\n   LIMIT 1\n   ```\n\nCombine all steps into the final SQL query:\n\n```sql\nSELECT Year, COUNT(*) AS concert_count\nFROM concert\nGROUP BY Year\nORDER BY concert_count DESC\nLIMIT 1;\n```\n\nReturn exactly one valid SQL statement.\n",
          "output": "select year, count(*) as concert_count from concert group by year order by concert_count desc limit 1"
        }
      },
      "gold_sql": "select year from concert group by year order by count(*) desc limit 1",
      "exact_match": false,
      "valid_sql": true,
      "exec_match": false
    },
    {
      "question": "What are the number of concerts that occurred in the stadium with the largest capacity ?",
      "db_id": "concert_singer",
      "agents": {
        "schema": {
          "prompt": "\nYou are a Schema Agent. Given a natural language question and table schemas, identify the relevant tables and columns.\n\nQuestion: What are the number of concerts that occurred in the stadium with the largest capacity ?\nSchemas:\nstadium:\n  Stadium_ID\n  Location\n  Name\n  Capacity\n  Highest\n  Lowest\n  Average\nsinger:\n  Singer_ID\n  Name\n  Country\n  Song_Name\n  Song_release_year\n  Age\n  Is_male\nconcert:\n  concert_ID\n  concert_Name\n  Theme\n  Stadium_ID\n  Year\nsinger_in_concert:\n  concert_ID\n  Singer_ID\n\nReturn a list of lines in the format:\nTable: col1, col2, ...\nOnly list relevant tables and columns needed to answer the question.\n",
          "output": "```\nTable: stadium, Capacity\nTable: concert, Stadium_ID\n```"
        },
        "subproblem": {
          "prompt": "\nYou are a Subproblem Agent. Your task is to decompose a natural language question into SQL subproblems.\n\nYou will be provided:\n- A natural language question\n- A textual schema summary that lists relevant tables and columns (generated by a Schema Agent)\n\nUse this information to infer which SQL clauses are likely needed other than SELECT (e.g., WHERE, GROUP BY, ORDER BY, JOIN, HAVING, LIMIT, INTERSECT).\n\nOutput a JSON object containing a list of subproblems:\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"...\" },\n    { \"clause\": \"WHERE\", \"expression\": \"...\" },\n    ...\n  ]\n}\n\nOnly output valid JSON \u2014 no markdown, no extra commentary.\n\nQuestion:\nWhat are the number of concerts that occurred in the stadium with the largest capacity ?\n\nSchema:\n```\nTable: stadium, Capacity\nTable: concert, Stadium_ID\n```\n",
          "output": "```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"COUNT(concert.Stadium_ID)\" },\n    { \"clause\": \"WHERE\", \"expression\": \"concert.Stadium_ID = stadium.ID\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"stadium.Capacity DESC\" },\n    { \"clause\": \"LIMIT\", \"expression\": \"1\" }\n  ]\n}\n```"
        },
        "plan": {
          "prompt": "\nYou are a Query Plan Agent. Using the question, schema info, and subproblems, generate a step-by-step SQL query plan.\n\nQuestion: What are the number of concerts that occurred in the stadium with the largest capacity ?\nSchema Info:\n```\nTable: stadium, Capacity\nTable: concert, Stadium_ID\n```\nSubproblems:\n```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"COUNT(concert.Stadium_ID)\" },\n    { \"clause\": \"WHERE\", \"expression\": \"concert.Stadium_ID = stadium.ID\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"stadium.Capacity DESC\" },\n    { \"clause\": \"LIMIT\", \"expression\": \"1\" }\n  ]\n}\n```\n\nProvide a concise and to-the-point plan, each step describing how to build parts of the SQL.\n",
          "output": "1. **Identify the Stadium with the Largest Capacity:**\n   - Use the `stadium` table to find the stadium with the largest capacity. This involves ordering the stadiums by their `Capacity` in descending order and selecting the top result.\n   - SQL: `SELECT ID FROM stadium ORDER BY Capacity DESC LIMIT 1`\n\n2. **Count Concerts in the Largest Stadium:**\n   - Use the `concert` table to count the number of concerts that occurred in the stadium identified in the first step.\n   - Join the `concert` table with the result from the first step to filter concerts that occurred in the stadium with the largest capacity.\n   - SQL: `SELECT COUNT(concert.Stadium_ID) FROM concert WHERE concert.Stadium_ID = (SELECT ID FROM stadium ORDER BY Capacity DESC LIMIT 1)`\n\n3. **Combine Steps into a Single Query:**\n   - Integrate the subquery from step 1 into the `WHERE` clause of the query in step 2 to form a complete SQL statement.\n   - Final SQL: \n     ```sql\n     SELECT COUNT(concert.Stadium_ID) \n     FROM concert \n     WHERE concert.Stadium_ID = (SELECT ID FROM stadium ORDER BY Capacity DESC LIMIT 1)\n     ```"
        },
        "sql": {
          "prompt": "\nYou are an SQL Generating Agent. Given the plan, write ONLY the final SQL query with no extra text or formatting.\n\nPlan:\n1. **Identify the Stadium with the Largest Capacity:**\n   - Use the `stadium` table to find the stadium with the largest capacity. This involves ordering the stadiums by their `Capacity` in descending order and selecting the top result.\n   - SQL: `SELECT ID FROM stadium ORDER BY Capacity DESC LIMIT 1`\n\n2. **Count Concerts in the Largest Stadium:**\n   - Use the `concert` table to count the number of concerts that occurred in the stadium identified in the first step.\n   - Join the `concert` table with the result from the first step to filter concerts that occurred in the stadium with the largest capacity.\n   - SQL: `SELECT COUNT(concert.Stadium_ID) FROM concert WHERE concert.Stadium_ID = (SELECT ID FROM stadium ORDER BY Capacity DESC LIMIT 1)`\n\n3. **Combine Steps into a Single Query:**\n   - Integrate the subquery from step 1 into the `WHERE` clause of the query in step 2 to form a complete SQL statement.\n   - Final SQL: \n     ```sql\n     SELECT COUNT(concert.Stadium_ID) \n     FROM concert \n     WHERE concert.Stadium_ID = (SELECT ID FROM stadium ORDER BY Capacity DESC LIMIT 1)\n     ```\n\nReturn exactly one valid SQL statement.\n",
          "output": "select count(concert.stadium_id) from concert where concert.stadium_id = (select id from stadium order by capacity desc limit 1)"
        }
      },
      "gold_sql": "select count(*) from concert where stadium_id = (select stadium_id from stadium order by capacity desc limit 1)",
      "exact_match": false,
      "valid_sql": false,
      "exec_match": false
    },
    {
      "question": "What is the model of the car with the smallest amount of horsepower?",
      "db_id": "car_1",
      "agents": {
        "schema": {
          "prompt": "\nYou are a Schema Agent. Given a natural language question and table schemas, identify the relevant tables and columns.\n\nQuestion: What is the model of the car with the smallest amount of horsepower?\nSchemas:\n\n\nReturn a list of lines in the format:\nTable: col1, col2, ...\nOnly list relevant tables and columns needed to answer the question.\n",
          "output": "To identify the relevant tables and columns needed to answer the question \"What is the model of the car with the smallest amount of horsepower?\", we need to focus on the columns that provide information about the car model and its horsepower. The relevant columns would typically include the car model and horsepower values.\n\nHere is the list of relevant tables and columns:\n\n```\nTable: model, horsepower\n```"
        },
        "subproblem": {
          "prompt": "\nYou are a Subproblem Agent. Your task is to decompose a natural language question into SQL subproblems.\n\nYou will be provided:\n- A natural language question\n- A textual schema summary that lists relevant tables and columns (generated by a Schema Agent)\n\nUse this information to infer which SQL clauses are likely needed other than SELECT (e.g., WHERE, GROUP BY, ORDER BY, JOIN, HAVING, LIMIT, INTERSECT).\n\nOutput a JSON object containing a list of subproblems:\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"...\" },\n    { \"clause\": \"WHERE\", \"expression\": \"...\" },\n    ...\n  ]\n}\n\nOnly output valid JSON \u2014 no markdown, no extra commentary.\n\nQuestion:\nWhat is the model of the car with the smallest amount of horsepower?\n\nSchema:\nTo identify the relevant tables and columns needed to answer the question \"What is the model of the car with the smallest amount of horsepower?\", we need to focus on the columns that provide information about the car model and its horsepower. The relevant columns would typically include the car model and horsepower values.\n\nHere is the list of relevant tables and columns:\n\n```\nTable: model, horsepower\n```\n",
          "output": "```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"model\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"horsepower ASC\" },\n    { \"clause\": \"LIMIT\", \"expression\": \"1\" }\n  ]\n}\n```"
        },
        "plan": {
          "prompt": "\nYou are a Query Plan Agent. Using the question, schema info, and subproblems, generate a step-by-step SQL query plan.\n\nQuestion: What is the model of the car with the smallest amount of horsepower?\nSchema Info:\nTo identify the relevant tables and columns needed to answer the question \"What is the model of the car with the smallest amount of horsepower?\", we need to focus on the columns that provide information about the car model and its horsepower. The relevant columns would typically include the car model and horsepower values.\n\nHere is the list of relevant tables and columns:\n\n```\nTable: model, horsepower\n```\nSubproblems:\n```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"model\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"horsepower ASC\" },\n    { \"clause\": \"LIMIT\", \"expression\": \"1\" }\n  ]\n}\n```\n\nProvide a concise and to-the-point plan, each step describing how to build parts of the SQL.\n",
          "output": "1. **SELECT Clause**: Start by selecting the column that contains the car model information. This is specified in the subproblem as `SELECT model`. This step will ensure that the query retrieves the model of the car.\n\n2. **ORDER BY Clause**: To find the car with the smallest amount of horsepower, sort the results by the `horsepower` column in ascending order. This is specified in the subproblem as `ORDER BY horsepower ASC`. Sorting in ascending order will place the car with the least horsepower at the top of the result set.\n\n3. **LIMIT Clause**: To get only the car model with the smallest horsepower, limit the result to just one record. This is specified in the subproblem as `LIMIT 1`. This step ensures that only the top result from the ordered list is returned, which corresponds to the car with the smallest horsepower.\n\nBy following these steps, the SQL query will efficiently retrieve the model of the car with the smallest amount of horsepower. The final SQL query will look like this:\n\n```sql\nSELECT model\nFROM your_table_name\nORDER BY horsepower ASC\nLIMIT 1;\n```\n\n(Note: Replace `your_table_name` with the actual name of the table containing the `model` and `horsepower` columns.)"
        },
        "sql": {
          "prompt": "\nYou are an SQL Generating Agent. Given the plan, write ONLY the final SQL query with no extra text or formatting.\n\nPlan:\n1. **SELECT Clause**: Start by selecting the column that contains the car model information. This is specified in the subproblem as `SELECT model`. This step will ensure that the query retrieves the model of the car.\n\n2. **ORDER BY Clause**: To find the car with the smallest amount of horsepower, sort the results by the `horsepower` column in ascending order. This is specified in the subproblem as `ORDER BY horsepower ASC`. Sorting in ascending order will place the car with the least horsepower at the top of the result set.\n\n3. **LIMIT Clause**: To get only the car model with the smallest horsepower, limit the result to just one record. This is specified in the subproblem as `LIMIT 1`. This step ensures that only the top result from the ordered list is returned, which corresponds to the car with the smallest horsepower.\n\nBy following these steps, the SQL query will efficiently retrieve the model of the car with the smallest amount of horsepower. The final SQL query will look like this:\n\n```sql\nSELECT model\nFROM your_table_name\nORDER BY horsepower ASC\nLIMIT 1;\n```\n\n(Note: Replace `your_table_name` with the actual name of the table containing the `model` and `horsepower` columns.)\n\nReturn exactly one valid SQL statement.\n",
          "output": "select model from your_table_name order by horsepower asc limit 1"
        }
      },
      "gold_sql": "select t1.model from car_names as t1 join cars_data as t2 on t1.makeid = t2.id order by t2.horsepower asc limit 1",
      "exact_match": false,
      "valid_sql": false,
      "exec_match": false
    }
  ],
  "true_samples": [
    {
      "question": "Show name, country, age for all singers ordered by age from the oldest to the youngest.",
      "db_id": "concert_singer",
      "agents": {
        "schema": {
          "prompt": "\nYou are a Schema Agent. Given a natural language question and table schemas, identify the relevant tables and columns.\n\nQuestion: Show name, country, age for all singers ordered by age from the oldest to the youngest.\nSchemas:\nstadium:\n  Stadium_ID\n  Location\n  Name\n  Capacity\n  Highest\n  Lowest\n  Average\nsinger:\n  Singer_ID\n  Name\n  Country\n  Song_Name\n  Song_release_year\n  Age\n  Is_male\nconcert:\n  concert_ID\n  concert_Name\n  Theme\n  Stadium_ID\n  Year\nsinger_in_concert:\n  concert_ID\n  Singer_ID\n\nReturn a list of lines in the format:\nTable: col1, col2, ...\nOnly list relevant tables and columns needed to answer the question.\n",
          "output": "```\nTable: singer\nColumns: Name, Country, Age\n```"
        },
        "subproblem": {
          "prompt": "\nYou are a Subproblem Agent. Your task is to decompose a natural language question into SQL subproblems.\n\nYou will be provided:\n- A natural language question\n- A textual schema summary that lists relevant tables and columns (generated by a Schema Agent)\n\nUse this information to infer which SQL clauses are likely needed other than SELECT (e.g., WHERE, GROUP BY, ORDER BY, JOIN, HAVING, LIMIT, INTERSECT).\n\nOutput a JSON object containing a list of subproblems:\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"...\" },\n    { \"clause\": \"WHERE\", \"expression\": \"...\" },\n    ...\n  ]\n}\n\nOnly output valid JSON \u2014 no markdown, no extra commentary.\n\nQuestion:\nShow name, country, age for all singers ordered by age from the oldest to the youngest.\n\nSchema:\n```\nTable: singer\nColumns: Name, Country, Age\n```\n",
          "output": "```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"Name, Country, Age\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"Age DESC\" }\n  ]\n}\n```"
        },
        "plan": {
          "prompt": "\nYou are a Query Plan Agent. Using the question, schema info, and subproblems, generate a step-by-step SQL query plan.\n\nQuestion: Show name, country, age for all singers ordered by age from the oldest to the youngest.\nSchema Info:\n```\nTable: singer\nColumns: Name, Country, Age\n```\nSubproblems:\n```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"Name, Country, Age\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"Age DESC\" }\n  ]\n}\n```\n\nProvide a concise and to-the-point plan, each step describing how to build parts of the SQL.\n",
          "output": "To construct the SQL query for the given question, follow these steps:\n\n1. **SELECT Clause**: \n   - Identify the columns that need to be retrieved from the table. According to the subproblem, we need to select the columns `Name`, `Country`, and `Age`.\n   - SQL: `SELECT Name, Country, Age`\n\n2. **FROM Clause**:\n   - Determine the table from which the data should be selected. The table in question is `singer`.\n   - SQL: `FROM singer`\n\n3. **ORDER BY Clause**:\n   - Specify the ordering of the results. The requirement is to order the singers by age from the oldest to the youngest, which means ordering by `Age` in descending order.\n   - SQL: `ORDER BY Age DESC`\n\n4. **Combine Clauses**:\n   - Combine the above clauses to form the complete SQL query.\n   - Final SQL: `SELECT Name, Country, Age FROM singer ORDER BY Age DESC`\n\nThis plan outlines the steps to construct the SQL query to retrieve the desired information, ordered as specified."
        },
        "sql": {
          "prompt": "\nYou are an SQL Generating Agent. Given the plan, write ONLY the final SQL query with no extra text or formatting.\n\nPlan:\nTo construct the SQL query for the given question, follow these steps:\n\n1. **SELECT Clause**: \n   - Identify the columns that need to be retrieved from the table. According to the subproblem, we need to select the columns `Name`, `Country`, and `Age`.\n   - SQL: `SELECT Name, Country, Age`\n\n2. **FROM Clause**:\n   - Determine the table from which the data should be selected. The table in question is `singer`.\n   - SQL: `FROM singer`\n\n3. **ORDER BY Clause**:\n   - Specify the ordering of the results. The requirement is to order the singers by age from the oldest to the youngest, which means ordering by `Age` in descending order.\n   - SQL: `ORDER BY Age DESC`\n\n4. **Combine Clauses**:\n   - Combine the above clauses to form the complete SQL query.\n   - Final SQL: `SELECT Name, Country, Age FROM singer ORDER BY Age DESC`\n\nThis plan outlines the steps to construct the SQL query to retrieve the desired information, ordered as specified.\n\nReturn exactly one valid SQL statement.\n",
          "output": "select name, country, age from singer order by age desc"
        }
      },
      "gold_sql": "select name, country, age from singer order by age desc",
      "exact_match": true,
      "valid_sql": true,
      "exec_match": true
    },
    {
      "question": "What are the names, countries, and ages for every singer in descending order of age?",
      "db_id": "concert_singer",
      "agents": {
        "schema": {
          "prompt": "\nYou are a Schema Agent. Given a natural language question and table schemas, identify the relevant tables and columns.\n\nQuestion: What are the names, countries, and ages for every singer in descending order of age?\nSchemas:\nstadium:\n  Stadium_ID\n  Location\n  Name\n  Capacity\n  Highest\n  Lowest\n  Average\nsinger:\n  Singer_ID\n  Name\n  Country\n  Song_Name\n  Song_release_year\n  Age\n  Is_male\nconcert:\n  concert_ID\n  concert_Name\n  Theme\n  Stadium_ID\n  Year\nsinger_in_concert:\n  concert_ID\n  Singer_ID\n\nReturn a list of lines in the format:\nTable: col1, col2, ...\nOnly list relevant tables and columns needed to answer the question.\n",
          "output": "```\nTable: singer\nColumns: Name, Country, Age\n```"
        },
        "subproblem": {
          "prompt": "\nYou are a Subproblem Agent. Your task is to decompose a natural language question into SQL subproblems.\n\nYou will be provided:\n- A natural language question\n- A textual schema summary that lists relevant tables and columns (generated by a Schema Agent)\n\nUse this information to infer which SQL clauses are likely needed other than SELECT (e.g., WHERE, GROUP BY, ORDER BY, JOIN, HAVING, LIMIT, INTERSECT).\n\nOutput a JSON object containing a list of subproblems:\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"...\" },\n    { \"clause\": \"WHERE\", \"expression\": \"...\" },\n    ...\n  ]\n}\n\nOnly output valid JSON \u2014 no markdown, no extra commentary.\n\nQuestion:\nWhat are the names, countries, and ages for every singer in descending order of age?\n\nSchema:\n```\nTable: singer\nColumns: Name, Country, Age\n```\n",
          "output": "```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"Name, Country, Age\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"Age DESC\" }\n  ]\n}\n```"
        },
        "plan": {
          "prompt": "\nYou are a Query Plan Agent. Using the question, schema info, and subproblems, generate a step-by-step SQL query plan.\n\nQuestion: What are the names, countries, and ages for every singer in descending order of age?\nSchema Info:\n```\nTable: singer\nColumns: Name, Country, Age\n```\nSubproblems:\n```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"Name, Country, Age\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"Age DESC\" }\n  ]\n}\n```\n\nProvide a concise and to-the-point plan, each step describing how to build parts of the SQL.\n",
          "output": "1. **SELECT Clause**: Start by selecting the columns that are required for the output. According to the subproblem, you need to select the `Name`, `Country`, and `Age` columns from the `singer` table. This forms the basis of the data you want to retrieve.\n\n   ```sql\n   SELECT Name, Country, Age\n   ```\n\n2. **FROM Clause**: Specify the table from which to retrieve the data. In this case, the data is coming from the `singer` table.\n\n   ```sql\n   FROM singer\n   ```\n\n3. **ORDER BY Clause**: To sort the results in descending order of age, use the `ORDER BY` clause. According to the subproblem, you need to order the results by the `Age` column in descending order.\n\n   ```sql\n   ORDER BY Age DESC\n   ```\n\n4. **Combine Clauses**: Combine all the parts to form the complete SQL query. This involves putting together the `SELECT`, `FROM`, and `ORDER BY` clauses to achieve the desired result.\n\n   ```sql\n   SELECT Name, Country, Age\n   FROM singer\n   ORDER BY Age DESC\n   ```\n\nThis plan outlines the steps to construct the SQL query that retrieves the names, countries, and ages of singers, sorted by age in descending order."
        },
        "sql": {
          "prompt": "\nYou are an SQL Generating Agent. Given the plan, write ONLY the final SQL query with no extra text or formatting.\n\nPlan:\n1. **SELECT Clause**: Start by selecting the columns that are required for the output. According to the subproblem, you need to select the `Name`, `Country`, and `Age` columns from the `singer` table. This forms the basis of the data you want to retrieve.\n\n   ```sql\n   SELECT Name, Country, Age\n   ```\n\n2. **FROM Clause**: Specify the table from which to retrieve the data. In this case, the data is coming from the `singer` table.\n\n   ```sql\n   FROM singer\n   ```\n\n3. **ORDER BY Clause**: To sort the results in descending order of age, use the `ORDER BY` clause. According to the subproblem, you need to order the results by the `Age` column in descending order.\n\n   ```sql\n   ORDER BY Age DESC\n   ```\n\n4. **Combine Clauses**: Combine all the parts to form the complete SQL query. This involves putting together the `SELECT`, `FROM`, and `ORDER BY` clauses to achieve the desired result.\n\n   ```sql\n   SELECT Name, Country, Age\n   FROM singer\n   ORDER BY Age DESC\n   ```\n\nThis plan outlines the steps to construct the SQL query that retrieves the names, countries, and ages of singers, sorted by age in descending order.\n\nReturn exactly one valid SQL statement.\n",
          "output": "select name, country, age from singer order by age desc"
        }
      },
      "gold_sql": "select name, country, age from singer order by age desc",
      "exact_match": true,
      "valid_sql": true,
      "exec_match": true
    },
    {
      "question": "What is the name and capacity for the stadium with highest average attendance?",
      "db_id": "concert_singer",
      "agents": {
        "schema": {
          "prompt": "\nYou are a Schema Agent. Given a natural language question and table schemas, identify the relevant tables and columns.\n\nQuestion: What is the name and capacity for the stadium with highest average attendance?\nSchemas:\nstadium:\n  Stadium_ID\n  Location\n  Name\n  Capacity\n  Highest\n  Lowest\n  Average\nsinger:\n  Singer_ID\n  Name\n  Country\n  Song_Name\n  Song_release_year\n  Age\n  Is_male\nconcert:\n  concert_ID\n  concert_Name\n  Theme\n  Stadium_ID\n  Year\nsinger_in_concert:\n  concert_ID\n  Singer_ID\n\nReturn a list of lines in the format:\nTable: col1, col2, ...\nOnly list relevant tables and columns needed to answer the question.\n",
          "output": "```\nTable: stadium: Name, Capacity, Average\n```"
        },
        "subproblem": {
          "prompt": "\nYou are a Subproblem Agent. Your task is to decompose a natural language question into SQL subproblems.\n\nYou will be provided:\n- A natural language question\n- A textual schema summary that lists relevant tables and columns (generated by a Schema Agent)\n\nUse this information to infer which SQL clauses are likely needed other than SELECT (e.g., WHERE, GROUP BY, ORDER BY, JOIN, HAVING, LIMIT, INTERSECT).\n\nOutput a JSON object containing a list of subproblems:\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"...\" },\n    { \"clause\": \"WHERE\", \"expression\": \"...\" },\n    ...\n  ]\n}\n\nOnly output valid JSON \u2014 no markdown, no extra commentary.\n\nQuestion:\nWhat is the name and capacity for the stadium with highest average attendance?\n\nSchema:\n```\nTable: stadium: Name, Capacity, Average\n```\n",
          "output": "```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"Name, Capacity\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"Average DESC\" },\n    { \"clause\": \"LIMIT\", \"expression\": \"1\" }\n  ]\n}\n```"
        },
        "plan": {
          "prompt": "\nYou are a Query Plan Agent. Using the question, schema info, and subproblems, generate a step-by-step SQL query plan.\n\nQuestion: What is the name and capacity for the stadium with highest average attendance?\nSchema Info:\n```\nTable: stadium: Name, Capacity, Average\n```\nSubproblems:\n```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"Name, Capacity\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"Average DESC\" },\n    { \"clause\": \"LIMIT\", \"expression\": \"1\" }\n  ]\n}\n```\n\nProvide a concise and to-the-point plan, each step describing how to build parts of the SQL.\n",
          "output": "1. **SELECT Clause**: Start by selecting the columns `Name` and `Capacity` from the `stadium` table. This will retrieve the necessary information about each stadium's name and its capacity.\n\n2. **ORDER BY Clause**: Order the results by the `Average` column in descending order. This will ensure that the stadiums are sorted from the highest average attendance to the lowest.\n\n3. **LIMIT Clause**: Apply a `LIMIT` of 1 to the query. This will restrict the result set to only the top entry, which corresponds to the stadium with the highest average attendance.\n\nBy following these steps, the SQL query will efficiently retrieve the name and capacity of the stadium with the highest average attendance."
        },
        "sql": {
          "prompt": "\nYou are an SQL Generating Agent. Given the plan, write ONLY the final SQL query with no extra text or formatting.\n\nPlan:\n1. **SELECT Clause**: Start by selecting the columns `Name` and `Capacity` from the `stadium` table. This will retrieve the necessary information about each stadium's name and its capacity.\n\n2. **ORDER BY Clause**: Order the results by the `Average` column in descending order. This will ensure that the stadiums are sorted from the highest average attendance to the lowest.\n\n3. **LIMIT Clause**: Apply a `LIMIT` of 1 to the query. This will restrict the result set to only the top entry, which corresponds to the stadium with the highest average attendance.\n\nBy following these steps, the SQL query will efficiently retrieve the name and capacity of the stadium with the highest average attendance.\n\nReturn exactly one valid SQL statement.\n",
          "output": "select name, capacity from stadium order by average desc limit 1"
        }
      },
      "gold_sql": "select name, capacity from stadium order by average desc limit 1",
      "exact_match": true,
      "valid_sql": true,
      "exec_match": true
    },
    {
      "question": "Find the number of concerts happened in the stadium with the highest capacity .",
      "db_id": "concert_singer",
      "agents": {
        "schema": {
          "prompt": "\nYou are a Schema Agent. Given a natural language question and table schemas, identify the relevant tables and columns.\n\nQuestion: Find the number of concerts happened in the stadium with the highest capacity .\nSchemas:\nstadium:\n  Stadium_ID\n  Location\n  Name\n  Capacity\n  Highest\n  Lowest\n  Average\nsinger:\n  Singer_ID\n  Name\n  Country\n  Song_Name\n  Song_release_year\n  Age\n  Is_male\nconcert:\n  concert_ID\n  concert_Name\n  Theme\n  Stadium_ID\n  Year\nsinger_in_concert:\n  concert_ID\n  Singer_ID\n\nReturn a list of lines in the format:\nTable: col1, col2, ...\nOnly list relevant tables and columns needed to answer the question.\n",
          "output": "```\nTable: stadium, Stadium_ID, Capacity\nTable: concert, concert_ID, Stadium_ID\n```"
        },
        "subproblem": {
          "prompt": "\nYou are a Subproblem Agent. Your task is to decompose a natural language question into SQL subproblems.\n\nYou will be provided:\n- A natural language question\n- A textual schema summary that lists relevant tables and columns (generated by a Schema Agent)\n\nUse this information to infer which SQL clauses are likely needed other than SELECT (e.g., WHERE, GROUP BY, ORDER BY, JOIN, HAVING, LIMIT, INTERSECT).\n\nOutput a JSON object containing a list of subproblems:\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"...\" },\n    { \"clause\": \"WHERE\", \"expression\": \"...\" },\n    ...\n  ]\n}\n\nOnly output valid JSON \u2014 no markdown, no extra commentary.\n\nQuestion:\nFind the number of concerts happened in the stadium with the highest capacity .\n\nSchema:\n```\nTable: stadium, Stadium_ID, Capacity\nTable: concert, concert_ID, Stadium_ID\n```\n",
          "output": "```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"COUNT(concert.concert_ID)\" },\n    { \"clause\": \"WHERE\", \"expression\": \"concert.Stadium_ID = stadium.Stadium_ID\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"stadium.Capacity DESC\" },\n    { \"clause\": \"LIMIT\", \"expression\": \"1\" }\n  ]\n}\n```"
        },
        "plan": {
          "prompt": "\nYou are a Query Plan Agent. Using the question, schema info, and subproblems, generate a step-by-step SQL query plan.\n\nQuestion: Find the number of concerts happened in the stadium with the highest capacity .\nSchema Info:\n```\nTable: stadium, Stadium_ID, Capacity\nTable: concert, concert_ID, Stadium_ID\n```\nSubproblems:\n```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"COUNT(concert.concert_ID)\" },\n    { \"clause\": \"WHERE\", \"expression\": \"concert.Stadium_ID = stadium.Stadium_ID\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"stadium.Capacity DESC\" },\n    { \"clause\": \"LIMIT\", \"expression\": \"1\" }\n  ]\n}\n```\n\nProvide a concise and to-the-point plan, each step describing how to build parts of the SQL.\n",
          "output": "1. **Identify the Stadium with the Highest Capacity:**\n   - Use the `stadium` table to find the stadium with the highest capacity. This involves ordering the stadiums by their `Capacity` in descending order and selecting the top record.\n   - SQL: `SELECT Stadium_ID FROM stadium ORDER BY Capacity DESC LIMIT 1`\n\n2. **Count Concerts in the Identified Stadium:**\n   - Use the result from step 1 to filter concerts that occurred in the stadium with the highest capacity.\n   - Join the `concert` table with the `stadium` table on `Stadium_ID` to ensure the concerts are matched with their respective stadiums.\n   - Count the number of concerts using the `COUNT` function.\n   - SQL: `SELECT COUNT(concert.concert_ID) FROM concert WHERE concert.Stadium_ID = (SELECT Stadium_ID FROM stadium ORDER BY Capacity DESC LIMIT 1)`\n\n3. **Combine Steps into a Single Query:**\n   - Integrate the subquery from step 1 into the `WHERE` clause of the main query in step 2 to form a complete SQL statement.\n   - Final SQL: \n     ```sql\n     SELECT COUNT(concert.concert_ID)\n     FROM concert\n     WHERE concert.Stadium_ID = (\n       SELECT Stadium_ID\n       FROM stadium\n       ORDER BY Capacity DESC\n       LIMIT 1\n     )\n     ```"
        },
        "sql": {
          "prompt": "\nYou are an SQL Generating Agent. Given the plan, write ONLY the final SQL query with no extra text or formatting.\n\nPlan:\n1. **Identify the Stadium with the Highest Capacity:**\n   - Use the `stadium` table to find the stadium with the highest capacity. This involves ordering the stadiums by their `Capacity` in descending order and selecting the top record.\n   - SQL: `SELECT Stadium_ID FROM stadium ORDER BY Capacity DESC LIMIT 1`\n\n2. **Count Concerts in the Identified Stadium:**\n   - Use the result from step 1 to filter concerts that occurred in the stadium with the highest capacity.\n   - Join the `concert` table with the `stadium` table on `Stadium_ID` to ensure the concerts are matched with their respective stadiums.\n   - Count the number of concerts using the `COUNT` function.\n   - SQL: `SELECT COUNT(concert.concert_ID) FROM concert WHERE concert.Stadium_ID = (SELECT Stadium_ID FROM stadium ORDER BY Capacity DESC LIMIT 1)`\n\n3. **Combine Steps into a Single Query:**\n   - Integrate the subquery from step 1 into the `WHERE` clause of the main query in step 2 to form a complete SQL statement.\n   - Final SQL: \n     ```sql\n     SELECT COUNT(concert.concert_ID)\n     FROM concert\n     WHERE concert.Stadium_ID = (\n       SELECT Stadium_ID\n       FROM stadium\n       ORDER BY Capacity DESC\n       LIMIT 1\n     )\n     ```\n\nReturn exactly one valid SQL statement.\n",
          "output": "select count(concert.concert_id) from concert where concert.stadium_id = ( select stadium_id from stadium order by capacity desc limit 1 )"
        }
      },
      "gold_sql": "select count(*) from concert where stadium_id = (select stadium_id from stadium order by capacity desc limit 1)",
      "exact_match": false,
      "valid_sql": true,
      "exec_match": true
    },
    {
      "question": "How much does the youngest dog weigh?",
      "db_id": "pets_1",
      "agents": {
        "schema": {
          "prompt": "\nYou are a Schema Agent. Given a natural language question and table schemas, identify the relevant tables and columns.\n\nQuestion: How much does the youngest dog weigh?\nSchemas:\nStudent:\n  StuID\n  LName\n  Fname\n  Age\n  Sex\n  Major\n  Advisor\n  city_code\nHas_Pet:\n  StuID\n  PetID\nPets:\n  PetID\n  PetType\n  pet_age\n  weight\n\nReturn a list of lines in the format:\nTable: col1, col2, ...\nOnly list relevant tables and columns needed to answer the question.\n",
          "output": "```\nTable: Pets, pet_age, weight\n```"
        },
        "subproblem": {
          "prompt": "\nYou are a Subproblem Agent. Your task is to decompose a natural language question into SQL subproblems.\n\nYou will be provided:\n- A natural language question\n- A textual schema summary that lists relevant tables and columns (generated by a Schema Agent)\n\nUse this information to infer which SQL clauses are likely needed other than SELECT (e.g., WHERE, GROUP BY, ORDER BY, JOIN, HAVING, LIMIT, INTERSECT).\n\nOutput a JSON object containing a list of subproblems:\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"...\" },\n    { \"clause\": \"WHERE\", \"expression\": \"...\" },\n    ...\n  ]\n}\n\nOnly output valid JSON \u2014 no markdown, no extra commentary.\n\nQuestion:\nHow much does the youngest dog weigh?\n\nSchema:\n```\nTable: Pets, pet_age, weight\n```\n",
          "output": "```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"weight\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"pet_age ASC\" },\n    { \"clause\": \"LIMIT\", \"expression\": \"1\" }\n  ]\n}\n```"
        },
        "plan": {
          "prompt": "\nYou are a Query Plan Agent. Using the question, schema info, and subproblems, generate a step-by-step SQL query plan.\n\nQuestion: How much does the youngest dog weigh?\nSchema Info:\n```\nTable: Pets, pet_age, weight\n```\nSubproblems:\n```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"weight\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"pet_age ASC\" },\n    { \"clause\": \"LIMIT\", \"expression\": \"1\" }\n  ]\n}\n```\n\nProvide a concise and to-the-point plan, each step describing how to build parts of the SQL.\n",
          "output": "To determine how much the youngest dog weighs, we can construct the SQL query step-by-step using the provided subproblems. Here's the plan:\n\n1. **SELECT Clause**: Start by selecting the column that contains the information we need, which is the weight of the dog. This is specified in the subproblem as:\n   ```sql\n   SELECT weight\n   ```\n\n2. **ORDER BY Clause**: To find the youngest dog, we need to order the results by the pet's age in ascending order. This ensures that the youngest dog appears first in the result set. Implement this using:\n   ```sql\n   ORDER BY pet_age ASC\n   ```\n\n3. **LIMIT Clause**: Since we are only interested in the weight of the youngest dog, we limit the result to just one record. This is done using:\n   ```sql\n   LIMIT 1\n   ```\n\nCombine these steps to form the complete SQL query:\n```sql\nSELECT weight\nFROM Pets\nORDER BY pet_age ASC\nLIMIT 1\n```\n\nThis query will return the weight of the youngest dog from the Pets table."
        },
        "sql": {
          "prompt": "\nYou are an SQL Generating Agent. Given the plan, write ONLY the final SQL query with no extra text or formatting.\n\nPlan:\nTo determine how much the youngest dog weighs, we can construct the SQL query step-by-step using the provided subproblems. Here's the plan:\n\n1. **SELECT Clause**: Start by selecting the column that contains the information we need, which is the weight of the dog. This is specified in the subproblem as:\n   ```sql\n   SELECT weight\n   ```\n\n2. **ORDER BY Clause**: To find the youngest dog, we need to order the results by the pet's age in ascending order. This ensures that the youngest dog appears first in the result set. Implement this using:\n   ```sql\n   ORDER BY pet_age ASC\n   ```\n\n3. **LIMIT Clause**: Since we are only interested in the weight of the youngest dog, we limit the result to just one record. This is done using:\n   ```sql\n   LIMIT 1\n   ```\n\nCombine these steps to form the complete SQL query:\n```sql\nSELECT weight\nFROM Pets\nORDER BY pet_age ASC\nLIMIT 1\n```\n\nThis query will return the weight of the youngest dog from the Pets table.\n\nReturn exactly one valid SQL statement.\n",
          "output": "select weight from pets order by pet_age asc limit 1"
        }
      },
      "gold_sql": "select weight from pets order by pet_age limit 1",
      "exact_match": false,
      "valid_sql": true,
      "exec_match": true
    },
    {
      "question": "What type of pet is the youngest animal, and how much does it weigh?",
      "db_id": "pets_1",
      "agents": {
        "schema": {
          "prompt": "\nYou are a Schema Agent. Given a natural language question and table schemas, identify the relevant tables and columns.\n\nQuestion: What type of pet is the youngest animal, and how much does it weigh?\nSchemas:\nStudent:\n  StuID\n  LName\n  Fname\n  Age\n  Sex\n  Major\n  Advisor\n  city_code\nHas_Pet:\n  StuID\n  PetID\nPets:\n  PetID\n  PetType\n  pet_age\n  weight\n\nReturn a list of lines in the format:\nTable: col1, col2, ...\nOnly list relevant tables and columns needed to answer the question.\n",
          "output": "```\nTable: Pets, PetType, pet_age, weight\n```"
        },
        "subproblem": {
          "prompt": "\nYou are a Subproblem Agent. Your task is to decompose a natural language question into SQL subproblems.\n\nYou will be provided:\n- A natural language question\n- A textual schema summary that lists relevant tables and columns (generated by a Schema Agent)\n\nUse this information to infer which SQL clauses are likely needed other than SELECT (e.g., WHERE, GROUP BY, ORDER BY, JOIN, HAVING, LIMIT, INTERSECT).\n\nOutput a JSON object containing a list of subproblems:\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"...\" },\n    { \"clause\": \"WHERE\", \"expression\": \"...\" },\n    ...\n  ]\n}\n\nOnly output valid JSON \u2014 no markdown, no extra commentary.\n\nQuestion:\nWhat type of pet is the youngest animal, and how much does it weigh?\n\nSchema:\n```\nTable: Pets, PetType, pet_age, weight\n```\n",
          "output": "```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"PetType, weight\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"pet_age ASC\" },\n    { \"clause\": \"LIMIT\", \"expression\": \"1\" }\n  ]\n}\n```"
        },
        "plan": {
          "prompt": "\nYou are a Query Plan Agent. Using the question, schema info, and subproblems, generate a step-by-step SQL query plan.\n\nQuestion: What type of pet is the youngest animal, and how much does it weigh?\nSchema Info:\n```\nTable: Pets, PetType, pet_age, weight\n```\nSubproblems:\n```json\n{\n  \"subproblems\": [\n    { \"clause\": \"SELECT\", \"expression\": \"PetType, weight\" },\n    { \"clause\": \"ORDER BY\", \"expression\": \"pet_age ASC\" },\n    { \"clause\": \"LIMIT\", \"expression\": \"1\" }\n  ]\n}\n```\n\nProvide a concise and to-the-point plan, each step describing how to build parts of the SQL.\n",
          "output": "1. **Identify the Columns to Select**: Start by selecting the columns that are needed to answer the question. According to the subproblems, we need to select the `PetType` and `weight` columns from the `Pets` table.\n\n2. **Determine the Sorting Order**: To find the youngest animal, sort the records by the `pet_age` column in ascending order. This will ensure that the youngest pet appears at the top of the result set.\n\n3. **Limit the Result Set**: Since we are only interested in the youngest pet, apply a `LIMIT` clause to restrict the result set to just one record. This will return only the first row from the sorted list, which corresponds to the youngest pet.\n\n4. **Construct the SQL Query**: Combine the above steps into a single SQL query:\n   ```sql\n   SELECT PetType, weight\n   FROM Pets\n   ORDER BY pet_age ASC\n   LIMIT 1;\n   ```\n\nThis plan ensures that the query retrieves the type and weight of the youngest pet by sorting the pets by age and limiting the result to the top entry."
        },
        "sql": {
          "prompt": "\nYou are an SQL Generating Agent. Given the plan, write ONLY the final SQL query with no extra text or formatting.\n\nPlan:\n1. **Identify the Columns to Select**: Start by selecting the columns that are needed to answer the question. According to the subproblems, we need to select the `PetType` and `weight` columns from the `Pets` table.\n\n2. **Determine the Sorting Order**: To find the youngest animal, sort the records by the `pet_age` column in ascending order. This will ensure that the youngest pet appears at the top of the result set.\n\n3. **Limit the Result Set**: Since we are only interested in the youngest pet, apply a `LIMIT` clause to restrict the result set to just one record. This will return only the first row from the sorted list, which corresponds to the youngest pet.\n\n4. **Construct the SQL Query**: Combine the above steps into a single SQL query:\n   ```sql\n   SELECT PetType, weight\n   FROM Pets\n   ORDER BY pet_age ASC\n   LIMIT 1;\n   ```\n\nThis plan ensures that the query retrieves the type and weight of the youngest pet by sorting the pets by age and limiting the result to the top entry.\n\nReturn exactly one valid SQL statement.\n",
          "output": "select pettype, weight from pets order by pet_age asc limit 1"
        }
      },
      "gold_sql": "select pettype, weight from pets order by pet_age limit 1",
      "exact_match": false,
      "valid_sql": true,
      "exec_match": true
    }
  ]
}